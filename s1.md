# S1 — Simulação Manual de Concorrência (Dijkstra e Peterson)

## Escopo
- Dois processos: `P0` e `P1`.
- Objetivo: **exclusão mútua** na seção crítica (SC).
- Simulações em passos, explorando *interleavings* (intercalações) que funcionam e os que falhariam sem o protocolo correto.

## Premissas
- Operações `sleep` representam atrasos que mudam a ordem de execução.
- Variáveis e primitivas são atômicas apenas quando indicado (ex.: `wait`/`signal`).

## Seção 1 — Dijkstra (Semáforo Binário)
- **Estrutura:** `mutex` inicializado com 1. Cada processo executa:
  - `wait(mutex)`; SC; `signal(mutex)`.

- **Cenário A (funciona):** interleaving com bloqueio correto
  - t0: `P0` chama `wait(mutex)`, `mutex=0`, entra na SC.
  - t1: `P1` chama `wait(mutex)`, bloqueia (fila do semáforo).
  - t2: `P0` sai da SC e chama `signal(mutex)`, `mutex=1`.
  - t3: `P1` é despertado, `wait(mutex)` completa, entra na SC.
  - **Resultado:** nunca há dupla entrada; exclusão mútua garantida.

- **Cenário B (falharia sem semáforo):** checagem não atômica
  - t0: `P0` verifica `mutex==1` (check separado de set), atraso.
  - t1: `P1` verifica `mutex==1` também.
  - t2: ambos “setam” `mutex=0` quase simultaneamente.
  - t3: ambos entram na SC (violação de exclusão).
  - **Observação:** com `wait` atômico, esse interleaving não ocorre.

- **Cenário C (bug de implementação):** esquecer `signal`
  - t0: `P0` faz `wait(mutex)` e entra na SC.
  - t1: `P0` sai da SC mas esquece `signal(mutex)`.
  - t2: `P1` chama `wait(mutex)` e bloqueia indefinidamente.
  - **Resultado:** deadlock por má implementação.

- **Conclusão:** com `wait/signal` corretos, a exclusão mútua é garantida; performance e *fairness* dependem da implementação do semáforo (ordem de despertar, FIFO etc.).

## Seção 2 — Peterson (2 processos)
- **Variáveis:** `flag0`, `flag1` (boolean), `turn` (0/1).
- **Protocolo em `P0`:**
  - `flag0=true; turn=1;`
  - `while(flag1 AND turn==1) { /* espera */ }`
  - entra na SC; sai com `flag0=false;`
- **Simétrico para `P1`.**

- **Cenário A (funciona):** competição simultânea
  - t0: `P0`: `flag0=true; turn=1`.
  - t1: `P1`: `flag1=true; turn=0`.
  - t2: `P0` verifica `flag1 AND turn==1`? **Não** (`turn==0`), entra na SC.
  - t3: `P1` verifica `flag0 AND turn==0`? **Sim**, espera.
  - t4: `P0` sai, `flag0=false`.
  - t5: `P1` reavalia, `flag0==false`, entra na SC.
  - **Resultado:** exclusão garantida, alternância justa.

- **Cenário B (funciona):** um interessado, outro não
  - t0: `P0` tenta entrar (seta `flag0`, define `turn`), `P1` está com `flag1==false`.
  - t1: `P0` verifica, condição de espera falsa, entra na SC.
  - **Resultado:** sem espera desnecessária.

- **Cenário C (falharia sem `turn`):** apenas *flags*
  - Versão defeituosa: `flag0=true; while(flag1) {}` e simétrico para `P1`.
  - t0: `P0` e `P1` setam `flag=true` quase simultaneamente.
  - t1: ambos verificam `flag do outro==true` e entram em espera ocupada.
  - Possível livramento por *timing* invertido, mas sem `turn` existem interleavings em que ambos passam (visibilidade/reordenação), **ou** ficam presos (deadlock/**livelock**). O `turn` resolve o impasse de simetria.

- **Cenário D (reordenação indevida):** setar `turn` antes de `flag`
  - Se `turn` for atualizado sem o par `flag` definido, pode induzir espera extra ou justiça desigual. A ordem “seta `flag`, depois `turn`” é parte da prova de correção.

- **Conclusão:** Peterson garante exclusão mútua, progresso e **espera limitada (*bounded waiting*)** sob duas threads/processos com memória compartilhada e visibilidade adequada; cenários problemáticos surgem ao remover `turn` ou alterar a ordem das escritas.

## Diagramas (Mermaid)

### Fluxograma — Dijkstra (semáforo binário)
```mermaid
flowchart TD
  %% P0
  P0_start["P0 tenta entrar"] --> P0_wait["wait(mutex)"]
  P0_wait -->|mutex livre| P0_sc["Seção Crítica P0"]
  P0_wait -->|mutex ocupado| P0_block["P0 bloqueado"]
  P0_sc --> P0_signal["signal(mutex)"]
  P0_signal --> P0_nc["Seção Não Crítica P0"]

  %% P1
  P1_start["P1 tenta entrar"] --> P1_wait["wait(mutex)"]
  P1_wait -->|mutex livre| P1_sc["Seção Crítica P1"]
  P1_wait -->|mutex ocupado| P1_block["P1 bloqueado"]
  P1_sc --> P1_signal["signal(mutex)"]
  P1_signal --> P1_nc["Seção Não Crítica P1"]

  %% Despertar do bloqueado após signal
  P0_signal --> P1_wait
  P1_signal --> P0_wait
```

### Diagrama de mensagens — Dijkstra (sequência de sincronização)
```mermaid
sequenceDiagram
  participant P0
  participant P1
  participant Mutex

  P0->>Mutex: wait()
  Mutex-->>P0: acquired (mutex=0)
  P1->>Mutex: wait()
  Mutex-->>P1: blocked
  P0->>P0: SC
  P0->>Mutex: signal()
  Mutex-->>P1: wake (mutex=1)
  P1->>Mutex: wait()
  Mutex-->>P1: acquired (mutex=0)
  P1->>P1: SC
  P1->>Mutex: signal()
  Mutex-->>P0: free (mutex=1)
```

### Fluxograma — Peterson (2 processos)
```mermaid
flowchart TD
  %% P0
  P0_setflag["flag0=true"] --> P0_turn["turn=1"]
  P0_turn --> P0_check{"flag1 AND turn==1?"}
  P0_check -- "sim" --> P0_wait["espera"]
  P0_check -- "não" --> P0_sc["Seção Crítica P0"]
  P0_wait --> P0_check
  P0_sc --> P0_exit["flag0=false"]

  %% P1
  P1_setflag["flag1=true"] --> P1_turn["turn=0"]
  P1_turn --> P1_check{"flag0 AND turn==0?"}
  P1_check -- "sim" --> P1_wait["espera"]
  P1_check -- "não" --> P1_sc["Seção Crítica P1"]
  P1_wait --> P1_check
  P1_sc --> P1_exit["flag1=false"]
```

### Diagrama de mensagens — Peterson (memória compartilhada)
```mermaid
sequenceDiagram
  participant P0
  participant P1
  participant Mem

  P0->>Mem: set flag0=true
  P0->>Mem: set turn=1
  P1->>Mem: set flag1=true
  P1->>Mem: set turn=0

  P0->>Mem: read flag1, turn
  alt flag1 AND turn==1
    P0->>P0: wait
  else
    P0->>P0: enter SC
    P0->>Mem: set flag0=false
  end

  P1->>Mem: read flag0, turn
  alt flag0 AND turn==0
    P1->>P1: wait
  else
    P1->>P1: enter SC
    P1->>Mem: set flag1=false
  end
```
